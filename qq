warning: LF will be replaced by CRLF in src/Chapter12.Tests/Chapter12.Tests.csproj.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in src/Chapter12/Chapter12.csproj.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in src/Chapter12/Listing12.07.DeclaringAGenericClassStack.cs.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in src/Chapter12/Listing12.13.InitializingAFieldWithTheDefaultOperator.cs.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in src/Chapter12/Listing12.21.NeedingTheTypeParameterToSupportAnInterfaceOrExceptionThrown.cs.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in src/Chapter12/Listing12.22.DeclaringAnInterfaceConstraint.cs.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in src/Chapter12/Listing12.23.DeclaringABaseClassConstraint.cs.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in src/Chapter12/Listing12.24.SpecifyingTheTypeParameterAsAValueType.cs.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in src/Chapter12/Listing12.26.RequiringADefaultConstructorConstraint.cs.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in src/Chapter12/Listing12.29.ConstraintExpressionsCannotRequireOperators.cs.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in src/Chapter12/Listing12.46.StackDeclaration.cs.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in src/Chapter12/Listing12.49.StackDefinition.cs.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in src/Chapter19/Cryptographer.cs.
The file will have its original line endings in your working directory
warning: LF will be replaced by CRLF in src/Chapter19/Listing19.02.UsingThreadPool.cs.
The file will have its original line endings in your working directory
[1mdiff --git a/src/Chapter12.Tests/Chapter12.Tests.csproj b/src/Chapter12.Tests/Chapter12.Tests.csproj[m
[1mindex bb751f3..c27455e 100644[m
[1m--- a/src/Chapter12.Tests/Chapter12.Tests.csproj[m
[1m+++ b/src/Chapter12.Tests/Chapter12.Tests.csproj[m
[36m@@ -1,6 +1,6 @@[m
 ï»¿<Project Sdk="Microsoft.NET.Sdk">[m
   <PropertyGroup>[m
[31m-    <ProductName>Chapter12.Tests</ProductName>[m
[32m+[m[32m    <ChapterNumber>12</ChapterNumber>[m
   </PropertyGroup>[m
   <Import Project="..\ChapterTests.props" />[m
   <ItemGroup>[m
[1mdiff --git a/src/Chapter12/Chapter12.csproj b/src/Chapter12/Chapter12.csproj[m
[1mindex 8e04c00..43e2816 100644[m
[1m--- a/src/Chapter12/Chapter12.csproj[m
[1m+++ b/src/Chapter12/Chapter12.csproj[m
[36m@@ -1,6 +1,6 @@[m
 ï»¿<Project Sdk="Microsoft.NET.Sdk">[m
   <PropertyGroup>[m
[31m-    <ProductName>Chapter12</ProductName>[m
[32m+[m[32m    <ChapterNumber>12</ChapterNumber>[m
   </PropertyGroup>[m
   <Import Project="..\Chapter.props" />[m
   <ItemGroup>[m
[1mdiff --git a/src/Chapter12/Listing12.07.DeclaringAGenericClassStack.cs b/src/Chapter12/Listing12.07.DeclaringAGenericClassStack.cs[m
[1mindex d2cf4ab..c37e060 100644[m
[1m--- a/src/Chapter12/Listing12.07.DeclaringAGenericClassStack.cs[m
[1m+++ b/src/Chapter12/Listing12.07.DeclaringAGenericClassStack.cs[m
[36m@@ -2,6 +2,11 @@[m [mnamespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_07[m
 {[m
     public class Stack<T>[m
     {[m
[32m+[m[32m        public Stack(int maxSize)[m
[32m+[m[32m        {[m
[32m+[m[32m            InternalItems = new T[maxSize];[m
[32m+[m[32m        }[m
[32m+[m
         // Use read-only field prior to C# 6.0[m
         private T[] InternalItems { get; }[m
 [m
[36m@@ -13,7 +18,7 @@[m [mnamespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_07[m
         public T Pop()[m
         {[m
             //...[m
[31m-            return InternalItems[0];//just for the example[m
[32m+[m[32m            return InternalItems[0]; //just for the example[m
         }[m
     }[m
 }[m
[1mdiff --git a/src/Chapter12/Listing12.13.InitializingAFieldWithTheDefaultOperator.cs b/src/Chapter12/Listing12.13.InitializingAFieldWithTheDefaultOperator.cs[m
[1mindex 0d3aee3..dd9d503 100644[m
[1m--- a/src/Chapter12/Listing12.13.InitializingAFieldWithTheDefaultOperator.cs[m
[1m+++ b/src/Chapter12/Listing12.13.InitializingAFieldWithTheDefaultOperator.cs[m
[36m@@ -7,7 +7,11 @@[m [mnamespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_13[m
         public Pair(T first)[m
         {[m
             First = first;[m
[31m-            Second = default(T);[m
[32m+[m[32m// Justifiction: Ignore warning pending struct/class constraints, later on in the chapter,[m[41m [m
[32m+[m[32m//               so that Second can be declared as T?.[m
[32m+[m[32m#pragma warning disable CS8601 // Possible null reference assignment.[m
[32m+[m[32m            Second = default;[m
[32m+[m[32m#pragma warning restore CS8601 // Possible null reference assignment.[m
         }[m
 [m
         public Pair(T first, T second)[m
[36m@@ -18,6 +22,5 @@[m [mnamespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_13[m
 [m
         public T First { get; set; }[m
         public T Second { get; set; }[m
[31m-[m
     }[m
 }[m
[1mdiff --git a/src/Chapter12/Listing12.20.NeedingTheTypeParameterToSupportAnInterface.cs b/src/Chapter12/Listing12.20.NeedingTheTypeParameterToSupportAnInterface.cs[m
[1mindex aa5695f..3ddf1e9 100644[m
[1m--- a/src/Chapter12/Listing12.20.NeedingTheTypeParameterToSupportAnInterface.cs[m
[1m+++ b/src/Chapter12/Listing12.20.NeedingTheTypeParameterToSupportAnInterface.cs[m
[36m@@ -7,6 +7,11 @@[m [mnamespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_20[m
 [m
     public class BinaryTree<T>[m
     {[m
[32m+[m[32m        public BinaryTree(T item)[m
[32m+[m[32m        {[m
[32m+[m[32m            Item = item;[m
[32m+[m[32m        }[m
[32m+[m
         public T Item { get; set; }[m
 [m
         public Pair<BinaryTree<T>> SubItems[m
[1mdiff --git a/src/Chapter12/Listing12.21.NeedingTheTypeParameterToSupportAnInterfaceOrExceptionThrown.cs b/src/Chapter12/Listing12.21.NeedingTheTypeParameterToSupportAnInterfaceOrExceptionThrown.cs[m
[1mindex 571640e..9b7b5ca 100644[m
[1m--- a/src/Chapter12/Listing12.21.NeedingTheTypeParameterToSupportAnInterfaceOrExceptionThrown.cs[m
[1m+++ b/src/Chapter12/Listing12.21.NeedingTheTypeParameterToSupportAnInterfaceOrExceptionThrown.cs[m
[36m@@ -5,28 +5,45 @@[m [mnamespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_21[m
 [m
     public class BinaryTree<T>[m
     {[m
[32m+[m[32m        public BinaryTree(T item)[m
[32m+[m[32m        {[m
[32m+[m[32m            Item = item;[m
[32m+[m[32m        }[m
[32m+[m
         public T Item { get; set; }[m
[31m-        public Pair<BinaryTree<T>> SubItems[m
[32m+[m[32m        public Pair<BinaryTree<T>?>? SubItems[m
         {[m
             get { return _SubItems; }[m
             set[m
             {[m
[31m-                IComparable<T> first;[m
[31m-                first = (IComparable<T>)value.First.Item;[m
[31m-[m
[31m-                if(first.CompareTo(value.Second.Item) < 0)[m
[31m-                {[m
[31m-                    // first is less than second[m
[31m-                    // ...[m
[31m-                }[m
[31m-                else[m
[32m+[m[32m                switch (value)[m
                 {[m
[31m-                    // second is less than or equal to first[m
[31m-                    // ...[m
[31m-                }[m
[32m+[m[32m                    case { First: null}:[m
[32m+[m[32m                        // First is null[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case { Second: null }:[m
[32m+[m[32m                        // Second is null[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case {[m[41m [m
[32m+[m[32m                            First: {Item: IComparable<T> first },[m[41m [m
[32m+[m[32m                            Second: {Item: T second } }:[m
[32m+[m[32m                        if(first.CompareTo(second) < 0)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            // first is less than second[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else[m
[32m+[m[32m                        {[m
[32m+[m[32m                            // second is less than or equal to first[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    default:[m
[32m+[m[32m                        throw new InvalidCastException([m
[32m+[m[32m                            @$"Unable to sort the items as {[m[41m [m
[32m+[m[32m                                typeof(T) } does not support IComparable<T>.");[m
[32m+[m[32m                };[m
                 _SubItems = value;[m
             }[m
         }[m
[31m-        private Pair<BinaryTree<T>> _SubItems;[m
[32m+[m[32m    private Pair<BinaryTree<T>?>? _SubItems;[m
     }[m
 }[m
[1mdiff --git a/src/Chapter12/Listing12.22.DeclaringAnInterfaceConstraint.cs b/src/Chapter12/Listing12.22.DeclaringAnInterfaceConstraint.cs[m
[1mindex 9129080..c638c51 100644[m
[1m--- a/src/Chapter12/Listing12.22.DeclaringAnInterfaceConstraint.cs[m
[1m+++ b/src/Chapter12/Listing12.22.DeclaringAnInterfaceConstraint.cs[m
[36m@@ -6,6 +6,11 @@[m [mnamespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_22[m
     public class BinaryTree<T>[m
         where T : System.IComparable<T>[m
     {[m
[32m+[m[32m        public BinaryTree(T item)[m
[32m+[m[32m        {[m
[32m+[m[32m            Item = item;[m
[32m+[m[32m        }[m
[32m+[m
         public T Item { get; set; }[m
 [m
         public Pair<BinaryTree<T>> SubItems[m
[36m@@ -13,20 +18,33 @@[m [mnamespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_22[m
             get { return _SubItems; }[m
             set[m
             {[m
[31m-                IComparable<T> first;[m
[31m-                // Notice that the cast can now be eliminated[m
[31m-                first = value.First.Item;[m
[31m-[m
[31m-                if(first.CompareTo(value.Second.Item) < 0)[m
[31m-                {[m
[31m-                    // first is less than second[m
[31m-                    //...[m
[31m-                }[m
[31m-                else[m
[32m+[m[32m                switch (value)[m
                 {[m
[31m-                    // second is less than or equal to first[m
[31m-                    //...[m
[31m-                }[m
[32m+[m[32m                    case { First: null }:[m
[32m+[m[32m                        // First is null[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case { Second: null }:[m
[32m+[m[32m                        // Second is null[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    case[m
[32m+[m[32m                    {[m
[32m+[m[32m                        First: { Item: T first },[m
[32m+[m[32m                        Second: { Item: T second }[m
[32m+[m[32m                    }:[m
[32m+[m[32m                        if (first.CompareTo(second) < 0)[m
[32m+[m[32m                        {[m
[32m+[m[32m                            // first is less than second[m
[32m+[m[32m                        }[m
[32m+[m[32m                        else[m
[32m+[m[32m                        {[m
[32m+[m[32m                            // second is less than or equal to first[m
[32m+[m[32m                        }[m
[32m+[m[32m                        break;[m
[32m+[m[32m                    default:[m
[32m+[m[32m                        throw new InvalidCastException([m
[32m+[m[32m                            @$"Unable to sort the items as {[m
[32m+[m[32m                                typeof(T) } does not support IComparable<T>.");[m
[32m+[m[32m                };[m
                 _SubItems = value;[m
             }[m
         }[m
[1mdiff --git a/src/Chapter12/Listing12.23.DeclaringABaseClassConstraint.cs b/src/Chapter12/Listing12.23.DeclaringABaseClassConstraint.cs[m
[1mindex e72a71f..11540d6 100644[m
[1m--- a/src/Chapter12/Listing12.23.DeclaringABaseClassConstraint.cs[m
[1m+++ b/src/Chapter12/Listing12.23.DeclaringABaseClassConstraint.cs[m
[36m@@ -2,6 +2,7 @@[m [mnamespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_23[m
 {[m
     public class EntityDictionary<TKey, TValue>[m
         : System.Collections.Generic.Dictionary<TKey, TValue>[m
[32m+[m[32m        where TKey: notnull[m
         where TValue : EntityBase[m
     {[m
         //...[m
[1mdiff --git a/src/Chapter12/Listing12.24.SpecifyingTheTypeParameterAsAValueType.cs b/src/Chapter12/Listing12.24.SpecifyingTheTypeParameterAsAValueType.cs[m
[1mindex 86e1536..0ec1788 100644[m
[1m--- a/src/Chapter12/Listing12.24.SpecifyingTheTypeParameterAsAValueType.cs[m
[1m+++ b/src/Chapter12/Listing12.24.SpecifyingTheTypeParameterAsAValueType.cs[m
[36m@@ -8,12 +8,12 @@[m [mnamespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_24[m
         where T : struct[m
     {[m
         // ...[m
[31m-        public string ToString(string format, IFormatProvider formatProvider)[m
[32m+[m[32m        public string ToString(string? format, IFormatProvider? formatProvider)[m
         {[m
             throw new NotImplementedException();[m
         }[m
 [m
[31m-        public int CompareTo(object obj)[m
[32m+[m[32m        public int CompareTo(object? obj)[m
         {[m
             throw new NotImplementedException();[m
         }[m
[1mdiff --git a/src/Chapter12/Listing12.26.RequiringADefaultConstructorConstraint.cs b/src/Chapter12/Listing12.26.RequiringADefaultConstructorConstraint.cs[m
[1mindex b050c37..9db9e4b 100644[m
[1m--- a/src/Chapter12/Listing12.26.RequiringADefaultConstructorConstraint.cs[m
[1m+++ b/src/Chapter12/Listing12.26.RequiringADefaultConstructorConstraint.cs[m
[36m@@ -4,8 +4,14 @@[m [mnamespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_26[m
     using System.Collections.Generic;[m
 [m
     public class EntityBase<TKey>[m
[32m+[m[32m        where TKey: notnull[m
     {[m
         public TKey Key { get; set; }[m
[32m+[m
[32m+[m[32m        public EntityBase(TKey key)[m
[32m+[m[32m        {[m
[32m+[m[32m            Key = key;[m
[32m+[m[32m        }[m
     }[m
 [m
     public class EntityDictionary<TKey, TValue> :[m
[36m@@ -17,8 +23,10 @@[m [mnamespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_26[m
 [m
         public TValue MakeValue(TKey key)[m
         {[m
[31m-            TValue newEntity = new TValue();[m
[31m-            newEntity.Key = key;[m
[32m+[m[32m            TValue newEntity = new TValue[m
[32m+[m[32m            {[m
[32m+[m[32m                Key = key[m
[32m+[m[32m            };[m
             Add(newEntity.Key, newEntity);[m
             return newEntity;[m
         }[m
[1mdiff --git a/src/Chapter12/Listing12.29.ConstraintExpressionsCannotRequireOperators.cs b/src/Chapter12/Listing12.29.ConstraintExpressionsCannotRequireOperators.cs[m
[1mindex d58c834..b5ceb0a 100644[m
[1m--- a/src/Chapter12/Listing12.29.ConstraintExpressionsCannotRequireOperators.cs[m
[1m+++ b/src/Chapter12/Listing12.29.ConstraintExpressionsCannotRequireOperators.cs[m
[36m@@ -1,13 +1,16 @@[m
[32m+[m[32musing System;[m
[32m+[m
 namespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_29[m
 {[m
     public abstract class MathEx<T>[m
     {[m
[32m+[m[32m#if INVALID_CODE[m
         public static T Add(T first, T second)[m
         {[m
             // Error: Operator '+' cannot be applied to [m
             // operands of type 'T' and 'T'[m
             // return first + second;[m
[31m-            return default(T);[m
         }[m
[32m+[m[32m#endif[m
     }[m
 }[m
[1mdiff --git a/src/Chapter12/Listing12.46.StackDeclaration.cs b/src/Chapter12/Listing12.46.StackDeclaration.cs[m
[1mindex 2abcdc4..5f33d3f 100644[m
[1m--- a/src/Chapter12/Listing12.46.StackDeclaration.cs[m
[1m+++ b/src/Chapter12/Listing12.46.StackDeclaration.cs[m
[36m@@ -1,13 +1,14 @@[m
[31m-ï»¿namespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_46[m
[32m+[m[32mï»¿// Justification: Only showing partial implementaiton.[m
[32m+[m[32m#pragma warning disable CS8618 // Non-nullable field is uninitialized. Consider declaring as nullable.[m
[32m+[m
[32m+[m[32mnamespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_46[m
 {[m
     using System;[m
[31m-// In an actual implementation we would get/set this[m
[31m-#pragma warning disable CS0169[m
 [m
     public class Stack<T> where T : IComparable[m
     {[m
         T[] items;[m
[31m-        // rest of the class here[m
[32m+[m
[32m+[m[32m        // ...[m
     }[m
[31m-#pragma warning restore CS0169[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/src/Chapter12/Listing12.49.StackDefinition.cs b/src/Chapter12/Listing12.49.StackDefinition.cs[m
[1mindex 2ab04a3..70c2042 100644[m
[1m--- a/src/Chapter12/Listing12.49.StackDefinition.cs[m
[1m+++ b/src/Chapter12/Listing12.49.StackDefinition.cs[m
[36m@@ -1,13 +1,14 @@[m
[32m+[m[32m// Justification: Only showing partial implementaiton.[m
[32m+[m[32m#pragma warning disable CS8618 // Non-nullable field is uninitialized. Consider declaring as nullable.[m
[32m+[m[32m#pragma warning disable IDE0051 // Remove unused private members[m
[32m+[m[32m#pragma warning disable IDE0044 // Add readonly modifier[m
[32m+[m
 using System.Collections.Generic;[m
 [m
 namespace AddisonWesley.Michaelis.EssentialCSharp.Chapter12.Listing12_49[m
 {[m
[31m-// In an actual implementation we would get/set this[m
[31m-#pragma warning disable CS0169[m
[31m-    [m
     public class Program[m
     {[m
         Stack<int> stack;[m
     }[m
[31m-#pragma warning restore CS0169[m
 }[m
